# values-rabbitmq-operator.yaml
extraDeploy:
  - apiVersion: rabbitmq.com/v1beta1
    kind: RabbitmqCluster
    metadata:
      name: rabbitmq
      namespace: rabbitmq
    spec:
      replicas: 3
      resources:
        requests:
          cpu:    1000m
          memory: 2Gi
        limits:
          memory: 10Gi
      rabbitmq:
        additionalConfig: |
          cluster_partition_handling = pause_minority
          disk_free_limit.relative   = 1.0
          collect_statistics_interval = 10000
      persistence:
        storage:          500Gi
        storageClassName: premium-rwo
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: app.kubernetes.io/name
                    operator: In
                    values:
                      - rabbitmq
              topologyKey: kubernetes.io/hostname

      # ───────────────────────────────────────────────────────────────────────────
      # Force all RabbitMQ pods onto the tainted rabbitmq-pool nodes
      override:
        statefulSet:
          spec:
            template:
              spec:
                # **this empty list is required** by the CRD schema
                containers: []

                # require RabbitMQ pods land only on your rabbitmq-pool
                nodeSelector:
                  rabbitmq.com/node-type: rabbitmq

                # allow them to tolerate that pool’s taint
                tolerations:
                  - key:      "rabbitmq.com/node-type"
                    operator: "Equal"
                    value:    "rabbitmq"
                    effect:   "NoSchedule"

  - apiVersion: policy/v1
    kind: PodDisruptionBudget
    metadata:
      name: rabbitmq
      namespace: rabbitmq
    spec:
      maxUnavailable: 1
      selector:
        matchLabels:
          app.kubernetes.io/name: rabbitmq

